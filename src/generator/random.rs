use crate::position::{Position, Region};
use rand::Rng;

#[derive(Debug, Copy, Clone)]
/// Generates an image of a given size to have a random assortment of
/// white blocks across the entire screen.  The blocks and background
/// can be configured to have specific colors.  The image can also
/// have a padding, and the blocks will only be generated by the box
/// bounded on all size within the image that the padding is in.
/// Note that if `(image_size - padding*2)` is not a multiple of
/// `block_size`, the blocks will be centered inside of the image.
pub struct RandomGenerator<P: image::Pixel + 'static> {
    /// The size of the box, in pixels.  This will be colored in the
    /// block color when picked.
    pub block_size: Position,
    /// The size of the image, in pixels.
    pub image_size: Position,
    /// The padding on all sides of the image.  The `x` component is
    /// for both the left and right, and the `y` component is for the
    /// top and bottom.
    pub padding: Position,
    /// The color to set for the block.  We generalize over the color
    /// type because this generator does not actually need to care
    /// about it.
    pub block_color: P,
    /// The color to set for the background color.  We generalize over
    /// the color type because this generator does not actually need
    /// to care about it.
    pub background_color: P,
    /// How often a given block should be colored in.  `0.5` is half
    /// of the time, `0.0` is none of the time, and `1.0` is all of
    /// the time.
    pub distribution: f64,
}

impl<P: image::Pixel + 'static> super::Generator<P> for RandomGenerator<P> {
    fn generate(&self) -> image::ImageBuffer<P, Vec<P::Subpixel>> {
        let center_adjustment: Position = (self.image_size - self.padding * 2) % self.block_size;
        let inner_region = Region::new(
            self.padding + center_adjustment / 2,
            self.image_size - self.padding - center_adjustment / 2,
        )
        .expect("top left should be greater than bottom right?");

        let blocks_count: Position = (self.image_size - self.padding * 2) / self.block_size;

        let rng = rand::thread_rng();
        let dist = rand::distributions::Bernoulli::new(self.distribution)
            .expect("distribution should be between 0.0 and 1.0");

        let blocks = (0..blocks_count.x())
            .map(|_| {
                rng.sample_iter(dist)
                    .take(blocks_count.y() as usize)
                    .collect::<Vec<bool>>()
            })
            .collect::<Vec<_>>();

        let index_of = |position: Position| {
            let adjusted: Position = (position - self.padding) / self.block_size;
            blocks
                .get(adjusted.x() as usize)
                .and_then(|v| v.get(adjusted.y() as usize))
                .cloned()
        };

        image::ImageBuffer::from_fn(self.image_size.x(), self.image_size.y(), |x, y| {
            let pos = Position::new(x, y);
            if !inner_region.contains(pos) {
                return self.background_color;
            }

            if index_of(pos).unwrap() {
                self.block_color
            } else {
                self.background_color
            }
        })
    }
}
